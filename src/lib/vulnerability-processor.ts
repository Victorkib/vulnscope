import { alertService } from './alert-service';
import type { Vulnerability } from '@/types/vulnerability';

export class VulnerabilityProcessor {
  private static instance: VulnerabilityProcessor;

  public static getInstance(): VulnerabilityProcessor {
    if (!VulnerabilityProcessor.instance) {
      VulnerabilityProcessor.instance = new VulnerabilityProcessor();
    }
    return VulnerabilityProcessor.instance;
  }

  /**
   * Process a new vulnerability through the alert system
   */
  async processNewVulnerability(vulnerability: Vulnerability): Promise<void> {
    try {
      console.log(`Processing new vulnerability: ${vulnerability.cveId}`);
      
      // Process through alert system
      await alertService.processVulnerability(vulnerability);
      
      console.log(`Successfully processed vulnerability: ${vulnerability.cveId}`);
    } catch (error) {
      console.error(`Error processing vulnerability ${vulnerability.cveId}:`, error);
      // Don't throw - we don't want alert processing failures to break vulnerability creation
    }
  }

  /**
   * Process multiple vulnerabilities (for batch operations)
   */
  async processVulnerabilities(vulnerabilities: Vulnerability[]): Promise<void> {
    // Process vulnerabilities in batches to prevent system overload
    const batchSize = 5;
    const batches = [];
    
    for (let i = 0; i < vulnerabilities.length; i += batchSize) {
      batches.push(vulnerabilities.slice(i, i + batchSize));
    }
    
    // Process batches sequentially with a small delay between them
    for (const batch of batches) {
      const promises = batch.map(vuln => this.processNewVulnerability(vuln));
      await Promise.allSettled(promises);
      
      // Small delay between batches to prevent system overload
      if (batches.indexOf(batch) < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }

  /**
   * Process vulnerability updates (when severity changes, etc.)
   */
  async processVulnerabilityUpdate(
    oldVulnerability: Vulnerability, 
    newVulnerability: Vulnerability
  ): Promise<void> {
    try {
      // Check if severity or other critical fields changed
      const severityChanged = oldVulnerability.severity !== newVulnerability.severity;
      const cvssChanged = oldVulnerability.cvssScore !== newVulnerability.cvssScore;
      const exploitChanged = oldVulnerability.exploitAvailable !== newVulnerability.exploitAvailable;
      
      if (severityChanged || cvssChanged || exploitChanged) {
        console.log(`Processing vulnerability update: ${newVulnerability.cveId}`);
        await alertService.processVulnerability(newVulnerability);
      }
    } catch (error) {
      console.error(`Error processing vulnerability update ${newVulnerability.cveId}:`, error);
    }
  }
}

// Export singleton instance
export const vulnerabilityProcessor = VulnerabilityProcessor.getInstance();
