import { alertService } from './alert-service';
import type { Vulnerability } from '@/types/vulnerability';

export class VulnerabilityProcessor {
  private static instance: VulnerabilityProcessor;

  public static getInstance(): VulnerabilityProcessor {
    if (!VulnerabilityProcessor.instance) {
      VulnerabilityProcessor.instance = new VulnerabilityProcessor();
    }
    return VulnerabilityProcessor.instance;
  }

  /**
   * Process a new vulnerability through the alert system
   */
  async processNewVulnerability(vulnerability: Vulnerability): Promise<void> {
    try {
      console.log(`Processing new vulnerability: ${vulnerability.cveId}`);
      
      // Process through alert system
      await alertService.processVulnerability(vulnerability);
      
      console.log(`Successfully processed vulnerability: ${vulnerability.cveId}`);
    } catch (error) {
      console.error(`Error processing vulnerability ${vulnerability.cveId}:`, error);
      // Don't throw - we don't want alert processing failures to break vulnerability creation
    }
  }

  /**
   * Process multiple vulnerabilities (for batch operations)
   */
  async processVulnerabilities(vulnerabilities: Vulnerability[]): Promise<void> {
    const promises = vulnerabilities.map(vuln => this.processNewVulnerability(vuln));
    await Promise.allSettled(promises);
  }

  /**
   * Process vulnerability updates (when severity changes, etc.)
   */
  async processVulnerabilityUpdate(
    oldVulnerability: Vulnerability, 
    newVulnerability: Vulnerability
  ): Promise<void> {
    try {
      // Check if severity or other critical fields changed
      const severityChanged = oldVulnerability.severity !== newVulnerability.severity;
      const cvssChanged = oldVulnerability.cvssScore !== newVulnerability.cvssScore;
      const exploitChanged = oldVulnerability.exploitAvailable !== newVulnerability.exploitAvailable;
      
      if (severityChanged || cvssChanged || exploitChanged) {
        console.log(`Processing vulnerability update: ${newVulnerability.cveId}`);
        await alertService.processVulnerability(newVulnerability);
      }
    } catch (error) {
      console.error(`Error processing vulnerability update ${newVulnerability.cveId}:`, error);
    }
  }
}

// Export singleton instance
export const vulnerabilityProcessor = VulnerabilityProcessor.getInstance();
