import { getDatabase } from '@/lib/mongodb';
import { adminAuthService } from '@/lib/admin-auth';
import type { Vulnerability } from '@/types/vulnerability';
import type { AdminUser, AdminAction } from '@/types/admin';

export interface VulnerabilityImportResult {
  success: number;
  failed: number;
  errors: string[];
  imported: Vulnerability[];
}

export interface VulnerabilityExportOptions {
  format: 'json' | 'csv' | 'xml' | 'pdf';
  filters?: {
    severity?: string[];
    dateRange?: { start: string; end: string };
    affectedSoftware?: string[];
    tags?: string[];
    search?: string;
  };
  includeMetadata?: boolean;
}

export interface AdminVulnerabilityStats {
  total: number;
  bySeverity: Record<string, number>;
  byCategory: Record<string, number>;
  withExploits: number;
  withPatches: number;
  trending: number;
  recentlyPublished: number;
  dataQuality: {
    completeness: number;
    accuracy: number;
    duplicates: number;
  };
}

export class AdminVulnerabilityService {
  private static instance: AdminVulnerabilityService;

  public static getInstance(): AdminVulnerabilityService {
    if (!AdminVulnerabilityService.instance) {
      AdminVulnerabilityService.instance = new AdminVulnerabilityService();
    }
    return AdminVulnerabilityService.instance;
  }

  /**
   * Create a new vulnerability (Admin only)
   */
  async createVulnerability(
    data: Omit<Vulnerability, 'createdAt' | 'updatedAt'>,
    adminUser: AdminUser
  ): Promise<Vulnerability> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      // Check if CVE ID already exists
      const existing = await vulnerabilitiesCollection.findOne({ cveId: data.cveId });
      if (existing) {
        throw new Error(`Vulnerability with CVE ID ${data.cveId} already exists`);
      }

      // Validate required fields
      this.validateVulnerabilityData(data);

      const now = new Date().toISOString();
      const vulnerability: Vulnerability = {
        ...data,
        createdAt: now,
        updatedAt: now,
      };

      await vulnerabilitiesCollection.insertOne(vulnerability as any);

      // Log admin action
      await adminAuthService.logAdminAction(
        adminUser.userId,
        'vulnerability_create',
        {
          targetId: data.cveId,
          targetType: 'vulnerability',
          oldValue: null,
          newValue: vulnerability,
          reason: 'Vulnerability created by admin',
          description: `Vulnerability ${data.cveId} created by admin`
        }
      );

      return vulnerability;
    } catch (error) {
      console.error('Error creating vulnerability:', error);
      throw new Error(`Failed to create vulnerability: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Update an existing vulnerability (Admin only)
   */
  async updateVulnerability(
    cveId: string,
    updates: Partial<Vulnerability>,
    adminUser: AdminUser
  ): Promise<Vulnerability> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      // Get current vulnerability
      const current = await vulnerabilitiesCollection.findOne({ cveId });
      if (!current) {
        throw new Error(`Vulnerability with CVE ID ${cveId} not found`);
      }

      // Validate updates
      if (updates.cveId && updates.cveId !== cveId) {
        // Check if new CVE ID already exists
        const existing = await vulnerabilitiesCollection.findOne({ cveId: updates.cveId });
        if (existing) {
          throw new Error(`Vulnerability with CVE ID ${updates.cveId} already exists`);
        }
      }

      // Remove fields that shouldn't be updated
      const { createdAt, _id, ...allowedUpdates } = updates as any;
      const now = new Date().toISOString();

      const result = await vulnerabilitiesCollection.updateOne(
        { cveId },
        {
          $set: {
            ...allowedUpdates,
            updatedAt: now,
          },
        }
      );

      if (result.matchedCount === 0) {
        throw new Error(`Vulnerability with CVE ID ${cveId} not found`);
      }

      // Get updated vulnerability
      const updated = await vulnerabilitiesCollection.findOne({ cveId: updates.cveId || cveId });
      if (!updated) {
        throw new Error('Failed to retrieve updated vulnerability');
      }

      // Log admin action
      await adminAuthService.logAdminAction(
        adminUser.userId,
        'vulnerability_update',
        {
          targetId: cveId,
          targetType: 'vulnerability',
          oldValue: current,
          newValue: updated,
          reason: 'Vulnerability updated by admin',
          description: `Vulnerability ${cveId} updated by admin`
        }
      );

      return updated as unknown as Vulnerability;
    } catch (error) {
      console.error('Error updating vulnerability:', error);
      throw new Error(`Failed to update vulnerability: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get a single vulnerability by CVE ID
   */
  async getVulnerability(cveId: string): Promise<Vulnerability | null> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');
      
      const vulnerability = await vulnerabilitiesCollection.findOne({ cveId });
      return vulnerability as unknown as Vulnerability | null;
    } catch (error) {
      console.error('Error fetching vulnerability:', error);
      throw new Error(`Failed to fetch vulnerability: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get vulnerabilities with pagination and filtering
   */
  async getVulnerabilities(options: {
    page?: number;
    limit?: number;
    search?: string;
    severity?: string[];
    category?: string[];
    exploitAvailable?: boolean;
    patchAvailable?: boolean;
    trending?: boolean;
    kev?: boolean;
  } = {}): Promise<{
    vulnerabilities: Vulnerability[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      pages: number;
      hasMore: boolean;
    };
  }> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');
      
      const {
        page = 1,
        limit = 25,
        search = '',
        severity = [],
        category = [],
        exploitAvailable,
        patchAvailable,
        trending,
        kev,
      } = options;
      
      const skip = (page - 1) * limit;
      
      // Build query
      const query: any = {};
      
      if (search) {
        query.$or = [
          { cveId: { $regex: search, $options: 'i' } },
          { title: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
          { affectedSoftware: { $in: [new RegExp(search, 'i')] } },
        ];
      }
      
      if (severity.length > 0) {
        query.severity = { $in: severity };
      }
      
      if (category.length > 0) {
        query.category = { $in: category };
      }
      
      if (exploitAvailable !== undefined) {
        query.exploitAvailable = exploitAvailable;
      }
      
      if (patchAvailable !== undefined) {
        query.patchAvailable = patchAvailable;
      }
      
      if (trending !== undefined) {
        query.trending = trending;
      }
      
      if (kev !== undefined) {
        query.kev = kev;
      }
      
      // Get total count
      const total = await vulnerabilitiesCollection.countDocuments(query);
      
      // Get vulnerabilities
      const vulnerabilities = await vulnerabilitiesCollection
        .find(query)
        .sort({ publishedDate: -1 })
        .skip(skip)
        .limit(limit)
        .toArray();
      
      return {
        vulnerabilities: vulnerabilities as unknown as Vulnerability[],
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
          hasMore: skip + limit < total,
        },
      };
    } catch (error) {
      console.error('Error fetching vulnerabilities:', error);
      throw new Error(`Failed to fetch vulnerabilities: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Delete a vulnerability (Admin only)
   */
  async deleteVulnerability(cveId: string, adminUser: AdminUser): Promise<void> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      // Get current vulnerability for logging
      const current = await vulnerabilitiesCollection.findOne({ cveId });
      if (!current) {
        throw new Error(`Vulnerability with CVE ID ${cveId} not found`);
      }

      // Delete the vulnerability
      const result = await vulnerabilitiesCollection.deleteOne({ cveId });
      if (result.deletedCount === 0) {
        throw new Error(`Vulnerability with CVE ID ${cveId} not found`);
      }

      // Log admin action
      await adminAuthService.logAdminAction(
        adminUser.userId,
        'vulnerability_delete',
        {
          targetId: cveId,
          targetType: 'vulnerability',
          oldValue: current,
          newValue: null,
          reason: 'Vulnerability deleted by admin',
          description: `Vulnerability ${cveId} deleted by admin`
        }
      );
    } catch (error) {
      console.error('Error deleting vulnerability:', error);
      throw new Error(`Failed to delete vulnerability: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Import vulnerabilities from file (Admin only)
   */
  async importVulnerabilities(
    vulnerabilities: Omit<Vulnerability, 'createdAt' | 'updatedAt'>[],
    adminUser: AdminUser
  ): Promise<VulnerabilityImportResult> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      const result: VulnerabilityImportResult = {
        success: 0,
        failed: 0,
        errors: [],
        imported: [],
      };

      for (const vulnData of vulnerabilities) {
        try {
          // Validate data
          this.validateVulnerabilityData(vulnData);

          // Check for duplicates
          const existing = await vulnerabilitiesCollection.findOne({ cveId: vulnData.cveId });
          if (existing) {
            result.failed++;
            result.errors.push(`CVE ID ${vulnData.cveId} already exists`);
            continue;
          }

          // Create vulnerability
          const now = new Date().toISOString();
          const vulnerability: Vulnerability = {
            ...vulnData,
            createdAt: now,
            updatedAt: now,
          };

          await vulnerabilitiesCollection.insertOne(vulnerability as any);
          result.success++;
          result.imported.push(vulnerability);
        } catch (error) {
          result.failed++;
          result.errors.push(`CVE ID ${vulnData.cveId}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      }

      // Log admin action
      await adminAuthService.logAdminAction(
        adminUser.userId,
        'vulnerability_import',
        {
          targetId: 'bulk_import',
          targetType: 'vulnerability',
          oldValue: null,
          newValue: { imported: result.success, failed: result.failed },
          reason: 'Bulk vulnerability import by admin',
          description: `Imported ${result.success} vulnerabilities, ${result.failed} failed`
        }
      );

      return result;
    } catch (error) {
      console.error('Error importing vulnerabilities:', error);
      throw new Error(`Failed to import vulnerabilities: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Export vulnerabilities (Admin only)
   */
  async exportVulnerabilities(
    options: VulnerabilityExportOptions,
    adminUser: AdminUser
  ): Promise<{ data: Vulnerability[]; format: string }> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      // Build query based on filters
      const query: any = {};
      if (options.filters) {
        if (options.filters.severity?.length) {
          query.severity = { $in: options.filters.severity };
        }
        if (options.filters.dateRange) {
          query.publishedDate = {
            $gte: options.filters.dateRange.start,
            $lte: options.filters.dateRange.end,
          };
        }
        if (options.filters.affectedSoftware?.length) {
          query.affectedSoftware = { $in: options.filters.affectedSoftware };
        }
        if (options.filters.tags?.length) {
          query.tags = { $in: options.filters.tags };
        }
        if (options.filters.search) {
          // Search across multiple fields
          query.$or = [
            { cveId: { $regex: options.filters.search, $options: 'i' } },
            { title: { $regex: options.filters.search, $options: 'i' } },
            { description: { $regex: options.filters.search, $options: 'i' } },
            { cweId: { $regex: options.filters.search, $options: 'i' } },
            { source: { $regex: options.filters.search, $options: 'i' } },
            { category: { $regex: options.filters.search, $options: 'i' } },
          ];
        }
      }

      const vulnerabilities = await vulnerabilitiesCollection.find(query).toArray();

      // Log admin action
      await adminAuthService.logAdminAction(
        adminUser.userId,
        'vulnerability_export',
        {
          targetId: 'bulk_export',
          targetType: 'vulnerability',
          oldValue: null,
          newValue: { exported: vulnerabilities.length, format: options.format },
          reason: 'Bulk vulnerability export by admin',
          description: `Exported ${vulnerabilities.length} vulnerabilities in ${options.format} format`
        }
      );

      return {
        data: vulnerabilities as unknown as Vulnerability[],
        format: options.format,
      };
    } catch (error) {
      console.error('Error exporting vulnerabilities:', error);
      throw new Error(`Failed to export vulnerabilities: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get admin-specific vulnerability analytics
   */
  async getAdminAnalytics(): Promise<AdminVulnerabilityStats> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      // Get basic stats
      const total = await vulnerabilitiesCollection.countDocuments();
      
      // Get severity distribution
      const severityStats = await vulnerabilitiesCollection.aggregate([
        { $group: { _id: '$severity', count: { $sum: 1 } } }
      ]).toArray();
      
      const bySeverity = severityStats.reduce((acc, stat) => {
        acc[stat._id] = stat.count;
        return acc;
      }, {} as Record<string, number>);

      // Get category distribution
      const categoryStats = await vulnerabilitiesCollection.aggregate([
        { $group: { _id: '$category', count: { $sum: 1 } } }
      ]).toArray();
      
      const byCategory = categoryStats.reduce((acc, stat) => {
        acc[stat._id] = stat.count;
        return acc;
      }, {} as Record<string, number>);

      // Get other metrics
      const withExploits = await vulnerabilitiesCollection.countDocuments({ exploitAvailable: true });
      const withPatches = await vulnerabilitiesCollection.countDocuments({ patchAvailable: true });
      const trending = await vulnerabilitiesCollection.countDocuments({ trending: true });
      
      // Recently published (last 30 days)
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const recentlyPublished = await vulnerabilitiesCollection.countDocuments({
        publishedDate: { $gte: thirtyDaysAgo.toISOString() }
      });

      // Data quality metrics
      const dataQuality = await this.calculateDataQuality();

      return {
        total,
        bySeverity,
        byCategory,
        withExploits,
        withPatches,
        trending,
        recentlyPublished,
        dataQuality,
      };
    } catch (error) {
      console.error('Error getting admin analytics:', error);
      throw new Error(`Failed to get admin analytics: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate vulnerability data
   */
  private validateVulnerabilityData(data: Omit<Vulnerability, 'createdAt' | 'updatedAt'>): void {
    if (!data.cveId || !data.cveId.trim()) {
      throw new Error('CVE ID is required');
    }
    if (!data.title || !data.title.trim()) {
      throw new Error('Title is required');
    }
    if (!data.description || !data.description.trim()) {
      throw new Error('Description is required');
    }
    if (!data.severity || !['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].includes(data.severity)) {
      throw new Error('Valid severity is required (CRITICAL, HIGH, MEDIUM, LOW)');
    }
    if (typeof data.cvssScore !== 'number' || data.cvssScore < 0 || data.cvssScore > 10) {
      throw new Error('CVSS score must be a number between 0 and 10');
    }
    if (!data.publishedDate) {
      throw new Error('Published date is required');
    }
    if (!data.affectedSoftware || !Array.isArray(data.affectedSoftware) || data.affectedSoftware.length === 0) {
      throw new Error('At least one affected software is required');
    }
  }

  /**
   * Calculate data quality metrics
   */
  private async calculateDataQuality(): Promise<{ completeness: number; accuracy: number; duplicates: number }> {
    try {
      const db = await getDatabase();
      const vulnerabilitiesCollection = db.collection<Vulnerability>('vulnerabilities');

      const total = await vulnerabilitiesCollection.countDocuments();
      if (total === 0) {
        return { completeness: 0, accuracy: 0, duplicates: 0 };
      }

      // Calculate completeness (percentage of records with all required fields)
      const completeRecords = await vulnerabilitiesCollection.countDocuments({
        cveId: { $exists: true, $nin: [null, ''] },
        title: { $exists: true, $nin: [null, ''] },
        description: { $exists: true, $nin: [null, ''] },
        severity: { $exists: true, $ne: null, $in: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'] },
        cvssScore: { $exists: true, $ne: null },
        publishedDate: { $exists: true, $nin: [null, ''] },
        affectedSoftware: { $exists: true, $ne: null, $not: { $size: 0 } },
      });

      const completeness = (completeRecords / total) * 100;

      // Calculate accuracy (percentage of records with valid CVSS scores)
      const accurateRecords = await vulnerabilitiesCollection.countDocuments({
        cvssScore: { $gte: 0, $lte: 10 },
        severity: { $in: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'] },
      });

      const accuracy = (accurateRecords / total) * 100;

      // Calculate duplicates (CVE IDs that appear more than once)
      const duplicateCves = await vulnerabilitiesCollection.aggregate([
        { $group: { _id: '$cveId', count: { $sum: 1 } } },
        { $match: { count: { $gt: 1 } } },
        { $count: 'duplicates' }
      ]).toArray();

      const duplicates = duplicateCves.length > 0 ? duplicateCves[0].duplicates : 0;

      return {
        completeness: Math.round(completeness * 100) / 100,
        accuracy: Math.round(accuracy * 100) / 100,
        duplicates,
      };
    } catch (error) {
      console.error('Error calculating data quality:', error);
      return { completeness: 0, accuracy: 0, duplicates: 0 };
    }
  }
}

export const adminVulnerabilityService = AdminVulnerabilityService.getInstance();
